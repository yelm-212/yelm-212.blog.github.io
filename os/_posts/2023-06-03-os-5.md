---
title:  "[OS] 프로세스 동기화, 교착 상태"
excerpt: "운영체제에 대해 학습한 내용을 정리하였습니다."

tags:
  - [Blog, OS, process, deadlock]

toc: true
toc_sticky: true
 
date: 2023-06-03
last_modified_at: 2023-06-03

---

# 메모리 관리

## 메모리 관리 필요성

- 폰 노이만 구조에서 메모리는 유일한 작업 공간이며 모든 프로그램은 메모리에 올라와야 실행이 가능하다.
- 과거에는 한 번에 한 작업만 처리해서 메모리 관리가 어렵지 않았으나... 오늘날 운영체제는 그렇지 않다. -> 메모리 관리가 더욱 중요해짐

## 가변 분할 방식

![](https://velog.velcdn.com/images%2Fchappi%2Fpost%2F10167b30-9774-4cd8-9e3a-7c827b78c6d6%2F10.png)

- 프로세스 크기에 따라 메모리 분할
- 외부 단편화 발생
	- 작은 프로세스가 작업 끝내면 빈 공간이 남음 (조각 모음)

## 고정 분할 방식

![](https://velog.velcdn.com/images%2Fchappi%2Fpost%2F8cb0c72c-63ac-43ba-b9da-a61e2e1765a8%2F11.png)

- 프로세스 크기에 관계없이 메모리 같은 사이즈로 나눔
- 관리가 비교적 수월함
- 메모리 배치 관리에 용이
- 외부 단편화가 일어나지 않기에 조각 모음을 할 필요가 없다.
- 하지만 공간 내부의 사용하지 못하는 메모리 공간 발생 -> 내부 단편화

# 가상 메모리 개요

## 가상 메모리 정의와 필요성

- 물리 메모리(실제 메모리)의 크기와 상관없이 메모리를 이용할 수 있도록 지원하는 기술
- 물리 메모리의 크기와 프로세스가 올라갈 메모리의 위치를 신경 쓰지 않고 프로그래밍이 가능해짐

- 크기가 다른 물리 메모리에서 일관된 프로세스 실행이 불가능함
- 기존에 차지하고 잇는 메모리들 고려 & 운영체제 공간도 고려해야함
- -> 가상 메모리 도입

## 페이징 기법

- 고정 분할 방식을 이용한 메모리 관리 기법
- 물리 주소 공간을 같은 크기로 나눠 사용

![](https://media.vlpt.us/images/chappi/post/18f268bd-8da3-492a-b672-4f942a138294/3.png)

![](https://media.vlpt.us/images/chappi/post/e86d6063-3a61-470c-9473-d4211e091a5e/4.png)

## 세그먼테이션 기법

![](https://media.vlpt.us/images/chappi/post/fbec6326-787d-4c2b-8e67-0d10d1744311/1.png)

- 가변 분할 방식을 이용한 가상 메모리 관리 기법
- 물리 메모리를 프로세스의 크기에 따라 가변적으로 나누어 사용
- 세그먼테이션 테이블에는 세그먼테이션 크기를 나타내는 limit, 물리 메모리 상의 시작 주소를 나타내는 address가 있다.
-  프로세스의 크기에 따라 메모리를 분할하기 때문에 매핑 테이블에 크기 정보를 포함
- 주어진 메모리 영역 초과 불가능 (limit)

# 가상 메모리 관리

## 요구 페이징

-  프로세스가 필요로 하는 데이터를 프로세스가 요청할 때 메모리로 가져오는 방법
- 메모리를 효율적으로 관리하고 응답 속도를 향상시키기 위해 사용

![](https://velog.velcdn.com/cloudflare/chappi/16d526bb-ed18-4333-9cd2-54991053961b/6.png)

- page fault: 물리 메모리에 요구 페이지가 존재하지 않을때 발생

## 페이지 교체 알고리즘

- page falut가 발생했을때, 스왑 영역으로 내보낼 페이지를 결정하는 알고리즘
- 사용할 가능성이 적은 페이지를 선정해야 하며 여러 알고리즘이 존재한다.

### FIFO

![](https://velog.velcdn.com/images/chappi/post/7734ec14-98da-4784-8e26-163514b8021e/2.png)

- 큐로 구현
- 가장 오래된 페이지를 대상 페이지로 선정
- 무조건 오래된 페이지 선정 -> 성능 떨어짐

### OPT

![](https://velog.velcdn.com/images/chappi/post/0a5d69c4-4f0e-4157-93fd-d3a98da89175/3.png)

-  앞으로 사용할 페이지를 미리 살펴보고 페이지 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 대상 페이지로 선정
- 실제로 구현 불가능함

### LRU, LFU

![](https://velog.velcdn.com/images/chappi/post/59052632-0758-4eb0-bbdb-b51dce646b06/4.png)

- LRU : 최근 최소 사용 알고리즘
- LFU : 최소 빈도 사용 알고리즘