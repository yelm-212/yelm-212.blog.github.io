---
title:  "[DB] 데이터베이스 (2)"
excerpt: "데이터베이스를 학습한 내용을 정리하였습니다."

tags:
  - [Blog, Database, join, sharding, Master-slave, 정규화, 이상현상, ACID, Lock]

toc: true
toc_sticky: true
 
date: 2023-04-19
last_modified_at: 2023-04-19
---

# Join
- Join은 데이터베이스에서 여러 개의 테이블을 조합하여 하나의 테이블을 생성하는 방법 중 하나로, Join을 사용하면 각 테이블에 저장된 데이터를 연결하여 더 많은 정보를 얻을 수 있다.
- Inner Join, Left Join, Right Join, Full Outer Join
	- 각 Join의 차이는 연결할 테이블의 기준이 되는 컬럼과 결과에 포함될 데이터의 종류에 따라 달라진다.
- Join을 사용하면 중복된 데이터를 줄이고 데이터베이스의 성능을 향상시킬 수 있으나, Join을 잘못 사용하면 데이터베이스의 성능에 부정적인 영향을 미칠 수도 있으므로 적절한 사용 방법을 알고 있어야 한다.

## 종류

1.  Inner Join

-   두 테이블에서 일치하는 데이터만 추출하는 Join
-   Join 조건을 만족하는 데이터만 결과로 출력됨
-   데이터의 정확도를 높일 수 있음

2.  Left Join

-   첫 번째 테이블 전체와 두 번째 테이블에서 일치하는 데이터만 추출하는 Join
-   두 번째 테이블에 일치하는 데이터가 없더라도 첫 번째 테이블의 데이터는 모두 출력됨
-   첫 번째 테이블의 데이터를 기준으로 두 번째 테이블의 데이터를 연결할 수 있어, 첫 번째 테이블의 모든 데이터를 유지하면서 두 테이블을 연결할 수 있음

3.  Right Join

-   두 번째 테이블 전체와 첫 번째 테이블에서 일치하는 데이터만 추출하는 Join
-   첫 번째 테이블에 일치하는 데이터가 없더라도 두 번째 테이블의 데이터는 모두 출력됨
-   두 번째 테이블의 데이터를 기준으로 첫 번째 테이블의 데이터를 연결할 수 있어, 두 번째 테이블의 모든 데이터를 유지하면서 두 테이블을 연결할 수 있음

4.  Full Outer Join

-   두 테이블에서 일치하는 데이터와 일치하지 않는 데이터를 모두 추출하는 Join
-   두 테이블 중 하나에만 있는 데이터도 추출됨
-   일치하지 않는 데이터는 NULL로 표시됨
-   두 테이블의 모든 데이터를 확인할 수 있음

# Sharding & Master/slave

## Sharding

-   대용량 데이터를 분산 저장 및 처리하기 위한 방법 중 하나
-   논리적인 단위인 Shard로 데이터를 분할하여 저장함
-   각 Shard는 독립적인 데이터를 가지고 있어, 데이터베이스 전체가 다운되지 않고도 일부 Shard만 이용 가능함
-   분산 환경에서 성능, 확장성, 가용성 등을 보장하고 비용을 절감할 수 있음

### 구현 방식

#### 수평 분할

-   테이블의 행(row)을 분할하는 방식
-   분산된 각각의 Shard는 동일한 스키마를 가짐
-   분산된 데이터가 골고루 분산되어 저장되어야 효율적인 분산 처리가 가능함
-   특정 행의 조회가 빈번한 경우는 효율성이 떨어질 수 있음

#### 수직 분할

-   테이블의 열(column)을 분할하는 방식
-   분산된 각각의 Shard는 서로 다른 스키마를 가짐
-   각 Shard는 자신이 담당하는 열을 처리하기 위한 전용 인스턴스를 가짐
-   데이터 분산 처리의 효율성이 높아짐
-   서로 다른 스키마를 가진 Shard 간의 Join 처리가 어려움

### Key 선택 방식

#### Range-based sharding

-   Shard Key의 값의 범위를 기준으로 Shard를 분할하는 방식
-   Shard Key를 기준으로 범위를 나누어 각 Shard에 할당함
-   Shard Key의 값이 골고루 분포되지 않으면 데이터 불균형 문제가 발생할 수 있음

#### Hash-based sharding

-   Shard Key의 값으로 해시 함수를 적용한 결과를 기준으로 Shard를 분할하는 방식
-   Shard Key의 값이 골고루 분포되도록 해시 함수를 선택함
-   특정 행이나 특정 키를 중심으로 분산될 가능성이 있음
-   범위 검색에 대한 제약이 있을 수 있음

#### List-based sharding

-   Shard Key의 값으로 목록(List)을 지정하여 Shard를 분할하는 방식
-   Shard Key의 값에 따라 해당하는 목록에 포함된 Shard에 데이터를 할당함
-   Shard Key의 값이 목록에 포함되어 있지 않으면 데이터를 저장할 Shard가 없는 경우가 발생할 수 있음

#### Composite sharding

-   두 개 이상의 Key를 조합하여 Shard를 분할하는 방식
-   각 Key 별로 분산 처리하는 방식을 조합함
-   예를 들어, 날짜 범위 기준과 지역 기준으로 Shard를 분할하는 것 등이 가능함

## Master/slave

-   대용량 데이터를 처리하기 위한 방법 중 하나
-   하나의 Master DB와 하나 이상의 Slave DB로 이루어짐
-   Master DB에서 데이터의 쓰기 작업이 이루어지면 Slave DB들은 그 데이터를 복제하여 저장
-   데이터베이스의 부하를 분산하여 처리하고 데이터의 안정성을 보장
-   Master DB가 다운되었을 경우 Slave DB 중 하나를 Master DB로 승격시켜 대처할 수 있음
-   Read 작업이 많은 경우 Slave DB를 이용하여 응답 속도를 향상시킬 수 있음

### Replication Lag

-   Master와 Slave 간의 데이터 복제 지연 시간을 의미
-   Master에서 변경된 데이터가 Slave로 복제되는데 시간이 걸릴 수 있음
-   데이터 복제 지연이 발생하면 Slave에서는 Master와의 데이터 불일치 문제가 발생할 수 있음

### Failover

-   Master Server가 다운되는 경우, Slave Server 중 하나가 Master로 승격되는 과정
-   Failover 과정에서는 Master 서버의 장애를 감지하고, 이에 대한 대응 및 Slave 서버에서 Master 서버로 승격하는 과정이 필요
-   Master 서버와 Slave 서버 간의 데이터 복제 지연이 발생할 경우, Failover 과정에서 문제가 발생할 수 있음
-   Master 서버의 복구 작업이 완료될 때까지 Slave 서버가 Master 역할을 수행해야 하는데, 이 과정에서 데이터 일관성을 유지해야 함
-   대부분의 시스템에서는 Failover 과정에서 일시적으로 데이터 일관성 문제가 발생할 수 있음
-   이를 위해 Replication Lag를 최소화하는 방법이나, 다중화(Multiplication) 기술을 적용하는 경우도 있음

# 이상 현상과 정규화

## 이상 현상 (Anomaly)

-   이상 현상이란 데이터베이스에서 데이터를 조작할 때 발생할 수 있는 비정상적인 상황을 의미함
-   이상 현상에는 삽입 이상, 삭제 이상, 갱신 이상이 있음

### 삽입 이상 (Insertion Anomaly)

-   데이터를 삽입할 때 원하지 않는 결과가 발생하는 현상
-   예를 들어, 주문 정보와 관련된 테이블에서 고객 정보가 없으면 주문 정보를 삽입할 수 없는 경우가 있음

### 삭제 이상 (Deletion Anomaly)

-   데이터를 삭제할 때 원하지 않는 결과가 발생하는 현상
-   예를 들어, 주문 정보와 관련된 테이블에서 고객 정보가 삭제되면 해당 고객의 주문 정보도 함께 삭제되는 경우가 있음

### 갱신 이상 (Update Anomaly)

-   데이터를 갱신할 때 원하지 않는 결과가 발생하는 현상
-   예를 들어, 주문 정보와 관련된 테이블에서 고객 정보를 수정하면 해당 고객의 모든 주문 정보도 함께 수정되는 경우가 있음

## 정규화 (Normalization)

-   데이터베이스의 설계 과정에서 중복된 데이터를 제거하고, 데이터를 구조화하여 이상 현상을 방지하는 과정을 의미
-   정규화는 1차 정규화부터 5차 정규화까지 총 5단계로 구성
-   정규화를 통해 데이터 일관성을 유지하고, 이상 현상을 방지
-   하지만 과도한 정규화는 쿼리 처리 속도를 떨어뜨리고, 테이블 간의 조인이 복잡해질 수 있으므로 적절한 수준의 정규화가 필요

### 1차 정규화 (1NF)

-   각각의 컬럼이 원자 값(Atomic Value)만을 가지도록 테이블을 구성하는 것을 의미
-   원자 값은 더 이상 분해할 수 없는 값으로, 컬럼에 중복된 데이터가 없도록 함

### 2차 정규화 (2NF)

-   1차 정규화를 만족하고, 기본 키가 아닌 컬럼이 기본 키에 완전 함수적 종속(Fully Functional Dependent) 되어 있어야 함
-   기본 키 이외의 모든 컬럼은 기본 키 전체에 의존하는 것이 아니라, 기본 키의 일부에만 의존

### 3차 정규화 (3NF)

-   2차 정규화를 만족하고, 비기본 키가 다른 비기본 키에 의존하지 않도록 테이블을 구성하는 것을 의미
-   컬럼 간의 이행적 함수 종속(Transitive Functional Dependency)을 제거하여 데이터 중복을 방지

### BCNF (Boyce-Codd Normal Form)

-   3차 정규화를 만족하고, 모든 결정자가 후보 키(Candidate Key)에 속하는 테이블을 의미
-   즉, 함수적 종속성을 만족시키면서 모든 결정자가 후보 키에 속하는 테이블을 구성

### 4차 정규화 (4NF)

-   다중 값 종속(Multi-valued Dependency)을 제거하는 정규화를 의미
-   다중 값 종속이란 하나의 키에 대해 여러 개의 값이 존재할 때, 이러한 값들이 각각의 값에 종속되어야 하는 경우를 의미

### 5차 정규화 (5NF)

-   조인 종속(Join Dependency)을 제거하는 정규화를 의미
-   조인 종속이란 두 개 이상의 테이블에서 조인을 해야만 원하는 정보를 얻을 수 있는 경우를 의미

# 트랜잭션
- 데이터베이스(Database)에서 수행되는 논리적인 작업의 단위
- 데이터베이스에서 일관성(Consistency)을 유지하기 위해 사용되며, 데이터베이스에 변경을 가할 때 사용

## ACID

데이터베이스 트랜잭션(Transaction)에서 보장해야 하는 네 가지 특성의 약어

1.  원자성(Atomicity)
    -   트랜잭션의 실행이 중간에 중단되면, 이전에 실행된 모든 작업을 롤백하여 이전 상태로 되돌리는 것을 보장
2.  일관성(Consistency)
    -   트랜잭션이 시작하기 전과 끝난 후에도 데이터베이스의 일관성이 유지되어야 함을 보장
3.  고립성(Isolation)
    -   하나의 트랜잭션이 실행되는 동안에는, 다른 트랜잭션에서 접근하지 못하도록 막아야 함을 보장
4.  지속성(Durability)
    -   트랜잭션이 완료되면, 그 결과는 영구적으로 데이터베이스에 저장되어야 함을 보장

## LOCK

- 다중 사용자 환경에서 동시에 접근하는 사용자들이 데이터베이스를 올바르게 유지하기 위해 사용되는 메커니즘
-  데이터베이스에서 동시성을 제어하기 위한 메커니즘
-  데이터베이스에 접근하는 여러 사용자들이 동시에 데이터를 수정하거나 읽을 때 일어나는 문제점을 해결하기 위해 사용
- 트랜잭션이 데이터베이스를 처리할 때 다른 트랜잭션에서 데이터에 접근하지 못하게 함

### 종류

-   SHARED LOCK: 다른 사용자들이 읽기만 가능하고 수정은 불가능하도록 LOCK을 걸 때 사용된다.
-   EXCLUSIVE LOCK: 다른 사용자들이 읽기 및 수정이 불가능하도록 LOCK을 걸 때 사용된다.

### 문제점

-   DEADLOCK: 두 개 이상의 트랜잭션이 LOCK을 얻지 못한 채 대기하는 상태로 무한정 기다리는 상황이 발생하는 것을 의미한다.
-   STARVATION: 한 트랜잭션이 LOCK을 계속해서 얻는 상황으로 다른 트랜잭션들이 영원히 LOCK을 얻지 못하는 경우를 의미한다.

### 최적화

-   락을 최소화하여 사용한다.
-   락의 범위를 최소화한다.
-   락 대기 시간을 최소화한다.

### 성능

-   LOCK은 동시성 제어를 위한 메커니즘이므로 과도한 LOCK 사용은 동시성을 제한하고, 성능을 저하시킬 수 있다. 따라서 LOCK은 적절한 수준에서 사용하는 것이 중요하다.
