---
title: "[JVM 밑바닥까지 파헤치기] 6장 클래스 파일 구조"
excerpt: "JVM 밑바닥까지 파헤치기 6장"
tags: [java, jvm]
toc: true
toc_sticky: true
date: 2025-01-01
last_modified_at: 2025-01-01
---

# 클래스 파일 구조

## 플랫폼 독립을 향한 초석

Java는 가상 머신에 의해 운영 체제나 기계어에 종속되지 않는, **플랫폼 독립적 저장 형식**을 택한다. 

또한, Java는 초기 설계 단계부터 가상 머신에서 다른 언어를 실행할 가능성을 염두에 두고 제작되어 타 언어를 지원할 수 있도록 하였다. (**언어 독립성**) 

이러한 특성 덕에, 오늘날 `Scala`, `Kotlin`, `Groovy` 등 다양한 언어가 JVM에서 실행될 수 있다.

이러한 언어 독립성을 보장하는 핵심은 **가상 머신**과 **바이트코드 저장 형식**이다. 

- 바이트코드 저장 형식 (`.class`) 
	- 컴파일러가 자바 class(`.java`)들을 바이트코드 파일(`.class`)로 변환한다.
- 가상 머신 
	- 바이트코드 파일을 클래스 로더에 의해 해석하고, JVM 메모리에 로드시킨다.

## 클래스 파일 구조 및 속성

### `.class` 파일 구조

Java의 클래스 파일 기본 구조는 다음과 같으며, 각 항목은 정해진 순서에 따라 나열된다.

- 매직 넘버 
	- 모든 클래스 파일의 처음 4바이트는 매직 넘버로 시작한다.
	- 해당 파일이 가상 머신이 허용하는 `.class` 파일임을 명시한다.  (`OXCAFEBABE`)

- Minor version(`minor_version`)
	- 2바이트로 JDK 마이너 버전을 명시한다.
- Major version(`major_version`)
	- 2바이트로 JDK 메이저 버전을 명시한다.

- Constant pool
	- `constant_pool_count` : 2바이트로, 상수 풀 항목 개수를 알려준다.
	- `constant_pool\[]` 
		- 문자열, 클래스와 인터페이스명, 필드명 등 현재 클래스 파일의 다양한 상수를 명시한다.
		- 각 `constant_pool` 테이블의 시작은 `tag` 바이트로 시작한다.
		- 1부터  `constant_pool_count- 1` 까지의 인덱스를 가진다.

- Access flags(`access_flags`)
	- 2바이트로, 해당 클래스 혹은 인터페이스 접근 권한을 명시한다.

| Flag명           | 값     | 설명                                                                |
| ---------------- | ------ | ------------------------------------------------------------------- |
| `ACC_PUBLIC`     | 0x0001 | `public`으로 선언. 패키지 외부에서 접근 가능.                       |
| `ACC_FINAL`      | 0x0010 | `final`로 선언. 하위 클래스가 허용되지 않음.                        |
| `ACC_SUPER`      | 0x0020 | `_invokespecial_` 명령어에 의해 상위 클래스 메서드를 특별히 처리함. |
| `ACC_INTERFACE`  | 0x0200 | 인터페이스                                                          |
| `ACC_ABSTRACT`   | 0x0400 | `abstract`로 선언. 인스턴스화 불가                                  | 
| `ACC_SYNTHETIC`  | 0x1000 | `synthetic`으로 선언. 소스 코드에 존재하지 않음.                    |
| `ACC_ANNOTATION` | 0x2000 | 애노테이션 타입으로 선언.                                           |
| `ACC_ENUM`       | 0x4000 | `enum` 타입으로 선언.                                               |


다음 클래스 파일의 인덱스 정보들은 상수 풀에 대해 유효한 인덱스로 구성된다.
- This class(`this_class`)
	- 현재 클래스의 인덱스를 표기한다.
- Super class(`super_class`)
	- 부모 클래스의 인덱스를 표기한다.
- Interfaces
	- `interfaces_count`
		- 현재 클래스 / 인터페이스의 direct superinterface 개수를 표기한다.
	- `interfaces[]` 
		- 구현된 인터페이스의 순서대로 인덱스를 표기한다.
		- 인덱스의 개수는 0 ≤ `i` < `interfaces_count`

- Fields 
	- `fields_count` 
		- 현재 클래스 / 인터페이스의 필드 수를 나타낸다.
	- `fields[]` :
		- 각 원소는 `field_info` 구조를 따른다.
		- 각 원소는 필드의 Access Flag(접근 권한), 필드명, type 등을 나타낸다.
```java
field_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

- Methods
	- `methods_count`
		- 메서드 테이블의 갯수를 나타낸다.
	- `methods[]`
		- 각 원소는 `method_info` 구조를 따른다.
```java
method_info {
    u2             access_flags;
    u2             name_index;
    u2             descriptor_index;
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
```

- Attributes
	- `attributes_count`
	- `attributes[]`
		- 각 원소는 `attribute_info` 구조를 따른다.
```java
attribute_info {
    u2 attribute_name_index;
    u4 attribute_length;
    u1 info[attribute_length];
}
```

### ByteViewer

`javap` 커맨드를 통해 바이트파일 구조를 확인할 수 있다.

다음 샘플 코드를 `javap -v -c` 옵션을 통해 컴파일하면, 클래스 구조를 확인할 수 있다.

```java
public class ByteCode {
    private static final String field = "string";

    public static String staticMethod() {
        return "staticMethod";
    }

}
```

![](/attatchments/20250101a77f9360.png)

## 바이트 코드 명령어 


---

출처

- [Oracle Java Virtual Machine Specification Ch4. The `class` File Format](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.9)
- [Wikipedia Java bytecode](https://en.wikipedia.org/wiki/Java_bytecode)
- [Wikipedia Java class file](https://en.wikipedia.org/wiki/Java_class_file)
- JVM 밑바닥까지 파헤치기 6장